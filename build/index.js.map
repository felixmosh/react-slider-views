{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["import * as React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport warning from \"warning\";\r\nimport { constant, checkIndexBounds, computeIndex, getDisplaySameSlide } from \"react-swipeable-views-core\";\r\n\r\nfunction addEventListener(node, event, handler, options) {\r\n    node.addEventListener(event, handler, options);\r\n    return {\r\n        remove() {\r\n            node.removeEventListener(event, handler, options);\r\n        },\r\n    };\r\n}\r\n\r\nconst styles = {\r\n    container: {\r\n        direction: \"ltr\",\r\n        display: \"flex\",\r\n        willChange: \"transform\",\r\n    },\r\n    slide: {\r\n        width: \"100%\",\r\n        WebkitFlexShrink: 0,\r\n        flexShrink: 0,\r\n        overflow: \"auto\",\r\n    },\r\n};\r\n\r\nconst axisProperties = {\r\n    root: {\r\n        x: {\r\n            overflowX: \"hidden\",\r\n        },\r\n        \"x-reverse\": {\r\n            overflowX: \"hidden\",\r\n        },\r\n        y: {\r\n            overflowY: \"hidden\",\r\n        },\r\n        \"y-reverse\": {\r\n            overflowY: \"hidden\",\r\n        },\r\n    },\r\n    flexDirection: {\r\n        x: \"row\",\r\n        \"x-reverse\": \"row-reverse\",\r\n        y: \"column\",\r\n        \"y-reverse\": \"column-reverse\",\r\n    },\r\n    transform: {\r\n        x: (translate) => `translate(${-translate}%, 0)`,\r\n        \"x-reverse\": (translate) => `translate(${translate}%, 0)`,\r\n        y: (translate) => `translate(0, ${-translate}%)`,\r\n        \"y-reverse\": (translate) => `translate(0, ${translate}%)`,\r\n    },\r\n    length: {\r\n        x: \"width\",\r\n        \"x-reverse\": \"width\",\r\n        y: \"height\",\r\n        \"y-reverse\": \"height\",\r\n    },\r\n    rotationMatrix: {\r\n        x: {\r\n            x: [1, 0],\r\n            y: [0, 1],\r\n        },\r\n        \"x-reverse\": {\r\n            x: [-1, 0],\r\n            y: [0, 1],\r\n        },\r\n        y: {\r\n            x: [0, 1],\r\n            y: [1, 0],\r\n        },\r\n        \"y-reverse\": {\r\n            x: [0, -1],\r\n            y: [1, 0],\r\n        },\r\n    },\r\n    scrollPosition: {\r\n        x: \"scrollLeft\",\r\n        \"x-reverse\": \"scrollLeft\",\r\n        y: \"scrollTop\",\r\n        \"y-reverse\": \"scrollTop\",\r\n    },\r\n    scrollLength: {\r\n        x: \"scrollWidth\",\r\n        \"x-reverse\": \"scrollWidth\",\r\n        y: \"scrollHeight\",\r\n        \"y-reverse\": \"scrollHeight\",\r\n    },\r\n    clientLength: {\r\n        x: \"clientWidth\",\r\n        \"x-reverse\": \"clientWidth\",\r\n        y: \"clientHeight\",\r\n        \"y-reverse\": \"clientHeight\",\r\n    },\r\n};\r\n\r\nfunction createTransition(property, options) {\r\n    const { duration, easeFunction, delay } = options;\r\n\r\n    return `${property} ${duration} ${easeFunction} ${delay}`;\r\n}\r\n\r\n// We are using a 2x2 rotation matrix.\r\nfunction applyRotationMatrix(touch, axis) {\r\n    const rotationMatrix = axisProperties.rotationMatrix[axis];\r\n\r\n    return {\r\n        pageX: rotationMatrix.x[0] * touch.pageX + rotationMatrix.x[1] * touch.pageY,\r\n        pageY: rotationMatrix.y[0] * touch.pageX + rotationMatrix.y[1] * touch.pageY,\r\n    };\r\n}\r\n\r\nfunction adaptMouse(event) {\r\n    event.touches = [{ pageX: event.pageX, pageY: event.pageY }];\r\n    return event;\r\n}\r\n\r\nexport function getDomTreeShapes(element, rootNode) {\r\n    let domTreeShapes = [];\r\n\r\n    while (element && element !== rootNode && element !== document.body) {\r\n        // We reach a Swipeable View, no need to look higher in the dom tree.\r\n        if (element.hasAttribute(\"data-swipeable\")) {\r\n            break;\r\n        }\r\n\r\n        const style = window.getComputedStyle(element);\r\n\r\n        if (\r\n            // Ignore the scroll children if the element is absolute positioned.\r\n            style.getPropertyValue(\"position\") === \"absolute\" ||\r\n            // Ignore the scroll children if the element has an overflowX hidden\r\n            style.getPropertyValue(\"overflow-x\") === \"hidden\"\r\n        ) {\r\n            domTreeShapes = [];\r\n        } else if (\r\n            (element.clientWidth > 0 && element.scrollWidth > element.clientWidth) ||\r\n            (element.clientHeight > 0 && element.scrollHeight > element.clientHeight)\r\n        ) {\r\n            // Ignore the nodes that have no width.\r\n            // Keep elements with a scroll\r\n            domTreeShapes.push({\r\n                element,\r\n                scrollWidth: element.scrollWidth,\r\n                scrollHeight: element.scrollHeight,\r\n                clientWidth: element.clientWidth,\r\n                clientHeight: element.clientHeight,\r\n                scrollLeft: element.scrollLeft,\r\n                scrollTop: element.scrollTop,\r\n            });\r\n        }\r\n\r\n        element = element.parentNode;\r\n    }\r\n\r\n    return domTreeShapes;\r\n}\r\n\r\n// We can only have one node at the time claiming ownership for handling the swipe.\r\n// Otherwise, the UX would be confusing.\r\n// That's why we use a singleton here.\r\nlet nodeWhoClaimedTheScroll = null;\r\n\r\nexport function findNativeHandler(params) {\r\n    const { domTreeShapes, pageX, startX, axis } = params;\r\n\r\n    return domTreeShapes.some((shape) => {\r\n        // Determine if we are going backward or forward.\r\n        let goingForward = pageX >= startX;\r\n        if (axis === \"x\" || axis === \"y\") {\r\n            goingForward = !goingForward;\r\n        }\r\n\r\n        // scrollTop is not always be an integer.\r\n        // https://github.com/jquery/api.jquery.com/issues/608\r\n        const scrollPosition = Math.round(shape[axisProperties.scrollPosition[axis]]);\r\n\r\n        const areNotAtStart = scrollPosition > 0;\r\n        const areNotAtEnd = scrollPosition + shape[axisProperties.clientLength[axis]] < shape[axisProperties.scrollLength[axis]];\r\n\r\n        if ((goingForward && areNotAtEnd) || (!goingForward && areNotAtStart)) {\r\n            nodeWhoClaimedTheScroll = shape.element;\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    });\r\n}\r\n\r\nexport const SwipeableViewsContext = React.createContext();\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n    SwipeableViewsContext.displayName = \"SliderViewsContext\";\r\n}\r\n\r\nclass SliderViews extends React.Component {\r\n    rootNode = null;\r\n    containerNode = null;\r\n    ignoreNextScrollEvents = false;\r\n    viewLength = 0;\r\n    startX = 0;\r\n    lastX = 0;\r\n    vx = 0;\r\n    startY = 0;\r\n    isSwiping = undefined;\r\n    started = false;\r\n    startIndex = 0;\r\n    transitionListener = null;\r\n    touchMoveListener = null;\r\n    activeSlide = null;\r\n    indexCurrent = null;\r\n    firstRenderTimeout = null;\r\n\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            checkIndexBounds(props);\r\n        }\r\n\r\n        this.state = {\r\n            indexLatest: props.index,\r\n            // Set to true as soon as the component is swiping.\r\n            // It's the state counter part of this.isSwiping.\r\n            isDragging: false,\r\n            // Help with SSR logic and lazy loading logic.\r\n            renderOnlyActive: !props.disableLazyLoading,\r\n            heightLatest: 0,\r\n            // Let the render method that we are going to display the same slide than previously.\r\n            displaySameSlide: true,\r\n        };\r\n        this.setIndexCurrent(props.index);\r\n    }\r\n\r\n    componentDidMount() {\r\n        // Subscribe to transition end events.\r\n        this.transitionListener = addEventListener(this.containerNode, \"transitionend\", (event) => {\r\n            if (event.target !== this.containerNode) {\r\n                return;\r\n            }\r\n\r\n            this.handleTransitionEnd();\r\n        });\r\n\r\n        // Block the thread to handle that event.\r\n        this.touchMoveListener = addEventListener(\r\n            this.rootNode,\r\n            \"touchmove\",\r\n            (event) => {\r\n                // Handling touch events is disabled.\r\n                if (this.props.disabled) {\r\n                    return;\r\n                }\r\n                this.handleSwipeMove(event);\r\n            },\r\n            {\r\n                passive: false,\r\n            }\r\n        );\r\n\r\n        if (!this.props.disableLazyLoading) {\r\n            this.firstRenderTimeout = setTimeout(() => {\r\n                this.setState({\r\n                    renderOnlyActive: false,\r\n                });\r\n            }, 0);\r\n        }\r\n\r\n        // Send all functions in an object if action param is set.\r\n        if (this.props.action) {\r\n            this.props.action({\r\n                updateHeight: this.updateHeight,\r\n            });\r\n        }\r\n    }\r\n\r\n    // UNSAFE_componentWillReceiveProps(nextProps) {\r\n    //     const { index } = nextProps;\r\n\r\n    //     if (typeof index === \"number\" && index !== this.props.index) {\r\n    //         if (process.env.NODE_ENV !== \"production\") {\r\n    //             checkIndexBounds(nextProps);\r\n    //         }\r\n\r\n    //         this.setIndexCurrent(index);\r\n    //         this.setState({\r\n    //             // If true, we are going to change the children. We shoudn't animate it.\r\n    //             displaySameSlide: getDisplaySameSlide(this.props, nextProps),\r\n    //             indexLatest: index,\r\n    //         });\r\n    //     }\r\n    // }\r\n\r\n    /**\r\n     *\r\n     * @param {import(\"../build\").ReactSliderViewsProps} prevProps\r\n     * @param {any} prevState\r\n     */\r\n    componentDidUpdate(prevProps, prevState) {\r\n        const { index } = this.props;\r\n        if (typeof index === \"number\" && index !== prevProps.index) {\r\n            if (process.env.NODE_ENV !== \"production\") {\r\n                checkIndexBounds(this.props);\r\n            }\r\n\r\n            this.setIndexCurrent(index);\r\n            this.setState({\r\n                // If true, we are going to change the children. We shoudn't animate it.\r\n                displaySameSlide: getDisplaySameSlide(prevProps, this.props),\r\n                indexLatest: index,\r\n            });\r\n        }\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        this.transitionListener.remove();\r\n        this.touchMoveListener.remove();\r\n        clearTimeout(this.firstRenderTimeout);\r\n    }\r\n\r\n    getSwipeableViewsContext() {\r\n        return {\r\n            slideUpdateHeight: () => {\r\n                this.updateHeight();\r\n            },\r\n        };\r\n    }\r\n\r\n    setIndexCurrent(indexCurrent) {\r\n        if (!this.props.animateTransitions && this.indexCurrent !== indexCurrent) {\r\n            this.handleTransitionEnd();\r\n        }\r\n\r\n        this.indexCurrent = indexCurrent;\r\n\r\n        if (this.containerNode) {\r\n            const { axis } = this.props;\r\n            const transform = axisProperties.transform[axis](indexCurrent * 100);\r\n            this.containerNode.style.WebkitTransform = transform;\r\n            this.containerNode.style.transform = transform;\r\n        }\r\n    }\r\n\r\n    setRootNode = (node) => {\r\n        this.rootNode = node;\r\n    };\r\n\r\n    setContainerNode = (node) => {\r\n        this.containerNode = node;\r\n    };\r\n\r\n    setActiveSlide = (node) => {\r\n        this.activeSlide = node;\r\n        this.updateHeight();\r\n    };\r\n\r\n    handleSwipeStart = (event) => {\r\n        const { axis } = this.props;\r\n\r\n        const touch = applyRotationMatrix(event.touches[0], axis);\r\n\r\n        this.viewLength = this.rootNode.getBoundingClientRect()[axisProperties.length[axis]];\r\n        this.startX = touch.pageX;\r\n        this.lastX = touch.pageX;\r\n        this.vx = 0;\r\n        this.startY = touch.pageY;\r\n        this.isSwiping = undefined;\r\n        this.started = true;\r\n\r\n        const computedStyle = window.getComputedStyle(this.containerNode);\r\n        const transform = computedStyle.getPropertyValue(\"-webkit-transform\") || computedStyle.getPropertyValue(\"transform\");\r\n\r\n        if (transform && transform !== \"none\") {\r\n            const transformValues = transform.split(\"(\")[1].split(\")\")[0].split(\",\");\r\n            const rootStyle = window.getComputedStyle(this.rootNode);\r\n\r\n            const tranformNormalized = applyRotationMatrix(\r\n                {\r\n                    pageX: parseInt(transformValues[4], 10),\r\n                    pageY: parseInt(transformValues[5], 10),\r\n                },\r\n                axis\r\n            );\r\n\r\n            this.startIndex =\r\n                -tranformNormalized.pageX / (this.viewLength - parseInt(rootStyle.paddingLeft, 10) - parseInt(rootStyle.paddingRight, 10)) || 0;\r\n        }\r\n    };\r\n\r\n    handleSwipeMove = (event) => {\r\n        // The touch start event can be cancel.\r\n        // Makes sure we set a starting point.\r\n        if (!this.started) {\r\n            this.handleTouchStart(event);\r\n            return;\r\n        }\r\n\r\n        // We are not supposed to hanlde this touch move.\r\n        if (nodeWhoClaimedTheScroll !== null && nodeWhoClaimedTheScroll !== this.rootNode) {\r\n            return;\r\n        }\r\n\r\n        const { axis, children, ignoreNativeScroll, onSwitching, resistance } = this.props;\r\n        const touch = applyRotationMatrix(event.touches[0], axis);\r\n\r\n        // We don't know yet.\r\n        if (this.isSwiping === undefined) {\r\n            const dx = Math.abs(touch.pageX - this.startX);\r\n            const dy = Math.abs(touch.pageY - this.startY);\r\n\r\n            const isSwiping = dx > dy && dx > constant.UNCERTAINTY_THRESHOLD;\r\n\r\n            // We let the parent handle the scroll.\r\n            if (\r\n                !resistance &&\r\n                (axis === \"y\" || axis === \"y-reverse\") &&\r\n                ((this.indexCurrent === 0 && this.startX < touch.pageX) ||\r\n                    (this.indexCurrent === React.Children.count(this.props.children) - 1 && this.startX > touch.pageX))\r\n            ) {\r\n                this.isSwiping = false;\r\n                return;\r\n            }\r\n\r\n            // We are likely to be swiping, let's prevent the scroll event.\r\n            if (dx > dy) {\r\n                event.preventDefault();\r\n            }\r\n\r\n            if (isSwiping === true || dy > constant.UNCERTAINTY_THRESHOLD) {\r\n                this.isSwiping = isSwiping;\r\n                this.startX = touch.pageX; // Shift the starting point.\r\n\r\n                return; // Let's wait the next touch event to move something.\r\n            }\r\n        }\r\n\r\n        if (this.isSwiping !== true) {\r\n            return;\r\n        }\r\n\r\n        // We are swiping, let's prevent the scroll event.\r\n        event.preventDefault();\r\n\r\n        // Low Pass filter.\r\n        this.vx = this.vx * 0.5 + (touch.pageX - this.lastX) * 0.5;\r\n        this.lastX = touch.pageX;\r\n\r\n        const { index, startX } = computeIndex({\r\n            children,\r\n            resistance,\r\n            pageX: touch.pageX,\r\n            startIndex: this.startIndex,\r\n            startX: this.startX,\r\n            viewLength: this.viewLength,\r\n        });\r\n\r\n        // Add support for native scroll elements.\r\n        if (nodeWhoClaimedTheScroll === null && !ignoreNativeScroll) {\r\n            const domTreeShapes = getDomTreeShapes(event.target, this.rootNode);\r\n            const hasFoundNativeHandler = findNativeHandler({\r\n                domTreeShapes,\r\n                startX: this.startX,\r\n                pageX: touch.pageX,\r\n                axis,\r\n            });\r\n\r\n            // We abort the touch move handler.\r\n            if (hasFoundNativeHandler) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        // We are moving toward the edges.\r\n        if (startX) {\r\n            this.startX = startX;\r\n        } else if (nodeWhoClaimedTheScroll === null) {\r\n            nodeWhoClaimedTheScroll = this.rootNode;\r\n        }\r\n\r\n        this.setIndexCurrent(index);\r\n\r\n        const callback = () => {\r\n            if (onSwitching) {\r\n                onSwitching(index, \"move\");\r\n            }\r\n        };\r\n\r\n        if (this.state.displaySameSlide || !this.state.isDragging) {\r\n            this.setState(\r\n                {\r\n                    displaySameSlide: false,\r\n                    isDragging: true,\r\n                },\r\n                callback\r\n            );\r\n        }\r\n\r\n        callback();\r\n    };\r\n\r\n    handleSwipeEnd = () => {\r\n        nodeWhoClaimedTheScroll = null;\r\n\r\n        // The touch start event can be cancel.\r\n        // Makes sure that a starting point is set.\r\n        if (!this.started) {\r\n            return;\r\n        }\r\n\r\n        this.started = false;\r\n\r\n        if (this.isSwiping !== true) {\r\n            return;\r\n        }\r\n\r\n        const indexLatest = this.state.indexLatest;\r\n        const indexCurrent = this.indexCurrent;\r\n        const delta = indexLatest - indexCurrent;\r\n\r\n        let indexNew;\r\n\r\n        // Quick movement\r\n        if (Math.abs(this.vx) > this.props.threshold) {\r\n            if (this.vx > 0) {\r\n                indexNew = Math.floor(indexCurrent);\r\n            } else {\r\n                indexNew = Math.ceil(indexCurrent);\r\n            }\r\n        } else if (Math.abs(delta) > this.props.hysteresis) {\r\n            // Some hysteresis with indexLatest.\r\n            indexNew = delta > 0 ? Math.floor(indexCurrent) : Math.ceil(indexCurrent);\r\n        } else {\r\n            indexNew = indexLatest;\r\n        }\r\n\r\n        const indexMax = React.Children.count(this.props.children) - 1;\r\n\r\n        if (indexNew < 0) {\r\n            indexNew = 0;\r\n        } else if (indexNew > indexMax) {\r\n            indexNew = indexMax;\r\n        }\r\n\r\n        this.setIndexCurrent(indexNew);\r\n        this.setState(\r\n            {\r\n                indexLatest: indexNew,\r\n                isDragging: false,\r\n            },\r\n            () => {\r\n                if (this.props.onSwitching) {\r\n                    this.props.onSwitching(indexNew, \"end\");\r\n                }\r\n\r\n                if (this.props.onChangeIndex && indexNew !== indexLatest) {\r\n                    this.props.onChangeIndex(indexNew, indexLatest, {\r\n                        reason: \"swipe\",\r\n                    });\r\n                }\r\n\r\n                // Manually calling handleTransitionEnd in that case as isn't otherwise.\r\n                if (indexCurrent === indexLatest) {\r\n                    this.handleTransitionEnd();\r\n                }\r\n            }\r\n        );\r\n    };\r\n\r\n    handleTouchStart = (event) => {\r\n        if (this.props.onTouchStart) {\r\n            this.props.onTouchStart(event);\r\n        }\r\n        this.handleSwipeStart(event);\r\n    };\r\n\r\n    handleTouchEnd = (event) => {\r\n        if (this.props.onTouchEnd) {\r\n            this.props.onTouchEnd(event);\r\n        }\r\n        this.handleSwipeEnd(event);\r\n    };\r\n\r\n    handleMouseDown = (event) => {\r\n        if (this.props.onMouseDown) {\r\n            this.props.onMouseDown(event);\r\n        }\r\n        event.persist();\r\n        this.handleSwipeStart(adaptMouse(event));\r\n    };\r\n\r\n    handleMouseUp = (event) => {\r\n        if (this.props.onMouseUp) {\r\n            this.props.onMouseUp(event);\r\n        }\r\n        this.handleSwipeEnd(adaptMouse(event));\r\n    };\r\n\r\n    handleMouseLeave = (event) => {\r\n        if (this.props.onMouseLeave) {\r\n            this.props.onMouseLeave(event);\r\n        }\r\n\r\n        // Filter out events\r\n        if (this.started) {\r\n            this.handleSwipeEnd(adaptMouse(event));\r\n        }\r\n    };\r\n\r\n    handleMouseMove = (event) => {\r\n        if (this.props.onMouseMove) {\r\n            this.props.onMouseMove(event);\r\n        }\r\n\r\n        // Filter out events\r\n        if (this.started) {\r\n            this.handleSwipeMove(adaptMouse(event));\r\n        }\r\n    };\r\n\r\n    handleScroll = (event) => {\r\n        if (this.props.onScroll) {\r\n            this.props.onScroll(event);\r\n        }\r\n\r\n        // Ignore events bubbling up.\r\n        if (event.target !== this.rootNode) {\r\n            return;\r\n        }\r\n\r\n        if (this.ignoreNextScrollEvents) {\r\n            this.ignoreNextScrollEvents = false;\r\n            return;\r\n        }\r\n\r\n        const indexLatest = this.state.indexLatest;\r\n        const indexNew = Math.ceil(event.target.scrollLeft / event.target.clientWidth) + indexLatest;\r\n\r\n        this.ignoreNextScrollEvents = true;\r\n        // Reset the scroll position.\r\n        event.target.scrollLeft = 0;\r\n\r\n        if (this.props.onChangeIndex && indexNew !== indexLatest) {\r\n            this.props.onChangeIndex(indexNew, indexLatest, {\r\n                reason: \"focus\",\r\n            });\r\n        }\r\n    };\r\n\r\n    updateHeight = () => {\r\n        if (this.activeSlide !== null) {\r\n            const child = this.activeSlide.children[0];\r\n            if (child !== undefined && child.offsetHeight !== undefined && this.state.heightLatest !== child.offsetHeight) {\r\n                this.setState({\r\n                    heightLatest: child.offsetHeight,\r\n                });\r\n            }\r\n        }\r\n    };\r\n\r\n    handleTransitionEnd() {\r\n        if (!this.props.onTransitionEnd) {\r\n            return;\r\n        }\r\n\r\n        // Filters out when changing the children\r\n        if (this.state.displaySameSlide) {\r\n            return;\r\n        }\r\n\r\n        // The rest callback is triggered when swiping. It's just noise.\r\n        // We filter it out.\r\n        if (!this.state.isDragging) {\r\n            this.props.onTransitionEnd();\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const {\r\n            action,\r\n            animateHeight,\r\n            animateTransitions,\r\n            axis,\r\n            children,\r\n            containerStyle: containerStyleProp,\r\n            disabled,\r\n            disableLazyLoading,\r\n            enableMouseEvents,\r\n            hysteresis,\r\n            ignoreNativeScroll,\r\n            index,\r\n            onChangeIndex,\r\n            onSwitching,\r\n            onTransitionEnd,\r\n            resistance,\r\n            slideStyle: slideStyleProp,\r\n            slideClassName,\r\n            springConfig,\r\n            style,\r\n            threshold,\r\n            ...other\r\n        } = this.props;\r\n\r\n        const { displaySameSlide, heightLatest, indexLatest, isDragging, renderOnlyActive } = this.state;\r\n        const touchEvents = !disabled\r\n            ? {\r\n                  onTouchStart: this.handleTouchStart,\r\n                  onTouchEnd: this.handleTouchEnd,\r\n              }\r\n            : {};\r\n        const mouseEvents =\r\n            !disabled && enableMouseEvents\r\n                ? {\r\n                      onMouseDown: this.handleMouseDown,\r\n                      onMouseUp: this.handleMouseUp,\r\n                      onMouseLeave: this.handleMouseLeave,\r\n                      onMouseMove: this.handleMouseMove,\r\n                  }\r\n                : {};\r\n\r\n        // There is no point to animate if we are already providing a height.\r\n        warning(\r\n            !animateHeight || !containerStyleProp || !containerStyleProp.height,\r\n            `react-swipeable-view: You are setting animateHeight to true but you are\r\nalso providing a custom height.\r\nThe custom height has a higher priority than the animateHeight property.\r\nSo animateHeight is most likely having no effect at all.`\r\n        );\r\n\r\n        const slideStyle = Object.assign({}, styles.slide, slideStyleProp);\r\n\r\n        let transition;\r\n        let WebkitTransition;\r\n\r\n        if (isDragging || !animateTransitions || displaySameSlide) {\r\n            transition = \"all 0s ease 0s\";\r\n            WebkitTransition = \"all 0s ease 0s\";\r\n        } else {\r\n            transition = createTransition(\"transform\", springConfig);\r\n            WebkitTransition = createTransition(\"-webkit-transform\", springConfig);\r\n\r\n            if (heightLatest !== 0) {\r\n                const additionalTranstion = `, ${createTransition(\"height\", springConfig)}`;\r\n                transition += additionalTranstion;\r\n                WebkitTransition += additionalTranstion;\r\n            }\r\n        }\r\n\r\n        const containerStyle = {\r\n            height: null,\r\n            WebkitFlexDirection: axisProperties.flexDirection[axis],\r\n            flexDirection: axisProperties.flexDirection[axis],\r\n            WebkitTransition,\r\n            transition,\r\n        };\r\n\r\n        // Apply the styles for SSR considerations\r\n        if (!renderOnlyActive) {\r\n            const transform = axisProperties.transform[axis](this.indexCurrent * 100);\r\n            containerStyle.WebkitTransform = transform;\r\n            containerStyle.transform = transform;\r\n        }\r\n\r\n        if (animateHeight) {\r\n            containerStyle.height = heightLatest;\r\n        }\r\n\r\n        return (\r\n            <SwipeableViewsContext.Provider value={this.getSwipeableViewsContext()}>\r\n                <div\r\n                    ref={this.setRootNode}\r\n                    style={Object.assign({}, axisProperties.root[axis], style)}\r\n                    {...other}\r\n                    {...touchEvents}\r\n                    {...mouseEvents}\r\n                    onScroll={this.handleScroll}>\r\n                    <div\r\n                        ref={this.setContainerNode}\r\n                        style={Object.assign({}, containerStyle, styles.container, containerStyleProp)}\r\n                        className=\"react-swipeable-view-container\">\r\n                        {React.Children.map(children, (child, indexChild) => {\r\n                            if (renderOnlyActive && indexChild !== indexLatest) {\r\n                                return null;\r\n                            }\r\n\r\n                            warning(\r\n                                React.isValidElement(child),\r\n                                `react-swipeable-view: one of the children provided is invalid: ${child}.\r\n  We are expecting a valid React Element`\r\n                            );\r\n\r\n                            let ref;\r\n                            let hidden = true;\r\n\r\n                            if (indexChild === indexLatest) {\r\n                                hidden = false;\r\n\r\n                                if (animateHeight) {\r\n                                    ref = this.setActiveSlide;\r\n                                    slideStyle.overflowY = \"hidden\";\r\n                                }\r\n                            }\r\n\r\n                            return (\r\n                                <div ref={ref} style={slideStyle} className={slideClassName} aria-hidden={hidden} data-swipeable=\"true\">\r\n                                    {child}\r\n                                </div>\r\n                            );\r\n                        })}\r\n                    </div>\r\n                </div>\r\n            </SwipeableViewsContext.Provider>\r\n        );\r\n    }\r\n}\r\n\r\n// Added as an ads for people using the React dev tools in production.\r\n// So they know, the tool used to build the awesome UI they\r\n// are looking at/retro engineering.\r\nSliderViews.displayName = \"ReactSliderViews\";\r\n\r\nSliderViews.propTypes = {\r\n    /**\r\n     * This is callback property. It's called by the component on mount.\r\n     * This is useful when you want to trigger an action programmatically.\r\n     * It currently only supports updateHeight() action.\r\n     *\r\n     * @param {object} actions This object contains all posible actions\r\n     * that can be triggered programmatically.\r\n     */\r\n    action: PropTypes.func,\r\n    /**\r\n     * If `true`, the height of the container will be animated to match the current slide height.\r\n     * Animating another style property has a negative impact regarding performance.\r\n     */\r\n    animateHeight: PropTypes.bool,\r\n    /**\r\n     * If `false`, changes to the index prop will not cause an animated transition.\r\n     */\r\n    animateTransitions: PropTypes.bool,\r\n    /**\r\n     * The axis on which the slides will slide.\r\n     */\r\n    axis: PropTypes.oneOf([\"x\", \"x-reverse\", \"y\", \"y-reverse\"]),\r\n    /**\r\n     * Use this property to provide your slides.\r\n     */\r\n    children: PropTypes.node.isRequired,\r\n    /**\r\n     * This is the inlined style that will be applied\r\n     * to each slide container.\r\n     */\r\n    containerStyle: PropTypes.object,\r\n    /**\r\n     * If `true`, it will disable touch events.\r\n     * This is useful when you want to prohibit the user from changing slides.\r\n     */\r\n    disabled: PropTypes.bool,\r\n    /**\r\n     * This is the config used to disable lazyloding,\r\n     * if `true` will render all the views in first rendering.\r\n     */\r\n    disableLazyLoading: PropTypes.bool,\r\n    /**\r\n     * If `true`, it will enable mouse events.\r\n     * This will allow the user to perform the relevant swipe actions with a mouse.\r\n     */\r\n    enableMouseEvents: PropTypes.bool,\r\n    /**\r\n     * Configure hysteresis between slides. This value determines how far\r\n     * should user swipe to switch slide.\r\n     */\r\n    hysteresis: PropTypes.number,\r\n    /**\r\n     * If `true`, it will ignore native scroll container.\r\n     * It can be used to filter out false positive that blocks the swipe.\r\n     */\r\n    ignoreNativeScroll: PropTypes.bool,\r\n    /**\r\n     * This is the index of the slide to show.\r\n     * This is useful when you want to change the default slide shown.\r\n     * Or when you have tabs linked to each slide.\r\n     */\r\n    index: PropTypes.number,\r\n    /**\r\n     * This is callback prop. It's call by the\r\n     * component when the shown slide change after a swipe made by the user.\r\n     * This is useful when you have tabs linked to each slide.\r\n     *\r\n     * @param {integer} index This is the current index of the slide.\r\n     * @param {integer} indexLatest This is the oldest index of the slide.\r\n     * @param {object} meta Meta data containing more information about the event.\r\n     */\r\n    onChangeIndex: PropTypes.func,\r\n    /**\r\n     * @ignore\r\n     */\r\n    onMouseDown: PropTypes.func,\r\n    /**\r\n     * @ignore\r\n     */\r\n    onMouseLeave: PropTypes.func,\r\n    /**\r\n     * @ignore\r\n     */\r\n    onMouseMove: PropTypes.func,\r\n    /**\r\n     * @ignore\r\n     */\r\n    onMouseUp: PropTypes.func,\r\n    /**\r\n     * @ignore\r\n     */\r\n    onScroll: PropTypes.func,\r\n    /**\r\n     * This is callback prop. It's called by the\r\n     * component when the slide switching.\r\n     * This is useful when you want to implement something corresponding\r\n     * to the current slide position.\r\n     *\r\n     * @param {integer} index This is the current index of the slide.\r\n     * @param {string} type Can be either `move` or `end`.\r\n     */\r\n    onSwitching: PropTypes.func,\r\n    /**\r\n     * @ignore\r\n     */\r\n    onTouchEnd: PropTypes.func,\r\n    /**\r\n     * @ignore\r\n     */\r\n    onTouchMove: PropTypes.func,\r\n    /**\r\n     * @ignore\r\n     */\r\n    onTouchStart: PropTypes.func,\r\n    /**\r\n     * The callback that fires when the animation comes to a rest.\r\n     * This is useful to defer CPU intensive task.\r\n     */\r\n    onTransitionEnd: PropTypes.func,\r\n    /**\r\n     * If `true`, it will add bounds effect on the edges.\r\n     */\r\n    resistance: PropTypes.bool,\r\n    /**\r\n     * This is the className that will be applied\r\n     * on the slide component.\r\n     */\r\n    slideClassName: PropTypes.string,\r\n    /**\r\n     * This is the inlined style that will be applied\r\n     * on the slide component.\r\n     */\r\n    slideStyle: PropTypes.object,\r\n    /**\r\n     * This is the config used to create CSS transitions.\r\n     * This is useful to change the dynamic of the transition.\r\n     */\r\n    springConfig: PropTypes.shape({\r\n        delay: PropTypes.string,\r\n        duration: PropTypes.string,\r\n        easeFunction: PropTypes.string,\r\n    }),\r\n    /**\r\n     * This is the inlined style that will be applied\r\n     * on the root component.\r\n     */\r\n    style: PropTypes.object,\r\n    /**\r\n     * This is the threshold used for detecting a quick swipe.\r\n     * If the computed speed is above this value, the index change.\r\n     */\r\n    threshold: PropTypes.number,\r\n};\r\n\r\nSliderViews.defaultProps = {\r\n    animateHeight: false,\r\n    animateTransitions: true,\r\n    axis: \"x\",\r\n    disabled: false,\r\n    disableLazyLoading: false,\r\n    enableMouseEvents: false,\r\n    hysteresis: 0.6,\r\n    ignoreNativeScroll: false,\r\n    index: 0,\r\n    threshold: 5,\r\n    springConfig: {\r\n        duration: \"0.35s\",\r\n        easeFunction: \"cubic-bezier(0.15, 0.3, 0.25, 1)\",\r\n        delay: \"0s\",\r\n    },\r\n    resistance: false,\r\n};\r\n\r\nexport default SliderViews;\r\n"],"names":["addEventListener","node","event","handler","options","remove","removeEventListener","styles","direction","display","willChange","width","WebkitFlexShrink","flexShrink","overflow","axisProperties","root","x","overflowX","y","overflowY","flexDirection","transform","translate","concat","length","rotationMatrix","scrollPosition","scrollLength","clientLength","createTransition","property","duration","easeFunction","delay","applyRotationMatrix","touch","axis","pageX","pageY","adaptMouse","touches","getDomTreeShapes","element","rootNode","domTreeShapes","document","body","hasAttribute","style","window","getComputedStyle","getPropertyValue","clientWidth","scrollWidth","clientHeight","scrollHeight","push","scrollLeft","scrollTop","parentNode","nodeWhoClaimedTheScroll","findNativeHandler","params","startX","some","shape","goingForward","Math","round","areNotAtStart","areNotAtEnd","SwipeableViewsContext","React","createContext","process","env","NODE_ENV","displayName","SliderViews","Component","props","_this","_classCallCheck","this","_defineProperty","_assertThisInitialized","_super","call","undefined","containerNode","activeSlide","updateHeight","viewLength","getBoundingClientRect","lastX","vx","startY","isSwiping","started","computedStyle","transformValues","split","rootStyle","tranformNormalized","parseInt","startIndex","paddingLeft","paddingRight","_this$props","children","ignoreNativeScroll","onSwitching","resistance","dx","abs","dy","constant","UNCERTAINTY_THRESHOLD","indexCurrent","Children","count","preventDefault","_computeIndex","computeIndex","index","target","setIndexCurrent","callback","state","displaySameSlide","isDragging","setState","handleTouchStart","indexNew","indexLatest","delta","threshold","floor","ceil","hysteresis","indexMax","onChangeIndex","reason","handleTransitionEnd","onTouchStart","handleSwipeStart","onTouchEnd","handleSwipeEnd","onMouseDown","persist","onMouseUp","onMouseLeave","onMouseMove","handleSwipeMove","onScroll","ignoreNextScrollEvents","child","offsetHeight","heightLatest","checkIndexBounds","renderOnlyActive","disableLazyLoading","_this2","transitionListener","touchMoveListener","disabled","passive","firstRenderTimeout","setTimeout","action","prevProps","prevState","getDisplaySameSlide","clearTimeout","_this3","slideUpdateHeight","value","animateTransitions","WebkitTransform","onTransitionEnd","_this4","_this$props2","animateHeight","containerStyleProp","containerStyle","enableMouseEvents","slideStyleProp","slideStyle","slideClassName","springConfig","other","_objectWithoutProperties","_excluded","_this$state","touchEvents","handleTouchEnd","mouseEvents","handleMouseDown","handleMouseUp","handleMouseLeave","handleMouseMove","warning","height","transition","WebkitTransition","Object","assign","additionalTranstion","WebkitFlexDirection","createElement","Provider","getSwipeableViewsContext","_extends","ref","setRootNode","handleScroll","setContainerNode","className","map","indexChild","isValidElement","hidden","setActiveSlide","propTypes","PropTypes","func","bool","oneOf","isRequired","object","number","onTouchMove","string","defaultProps"],"mappings":"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"}